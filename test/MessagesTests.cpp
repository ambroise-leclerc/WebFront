#include <weblink/Messages.hpp>

#include <catch2/catch.hpp>

using namespace webfront;
SCENARIO("Handshake message") {
    std::array<uint8_t, 2> raw{0x00, 0x00};
    auto handshake = msg::Handshake::castFromRawData(std::span(reinterpret_cast<const std::byte*>(raw.data()), raw.size()));

    REQUIRE(sizeof(*handshake) == 2);
    REQUIRE(handshake->getEndian() == msg::JSEndian::little);
}

SCENARIO("Ack message") {
    msg::Ack ack;

    REQUIRE(sizeof(ack) == 2);
}

SCENARIO("FunctionCall") {
    GIVEN("Raw data of a call to 'print' function with a small string as parameter") {
        std::array<uint8_t, 36> raw{0x03, 0x02, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x04, 0x05, 0x70, 0x72,
                                    0x69, 0x6e, 0x74, 0x04, 0x13, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57,
                                    0x6f, 0x72, 0x6c, 0x64, 0x20, 0x6f, 0x66, 0x20, 0x32, 0x30, 0x32, 0x32};

        auto functionCall =
          msg::FunctionCall::castFromRawData(std::span(reinterpret_cast<const std::byte*>(raw.data()), raw.size()));
        REQUIRE(functionCall->getParametersCount() == 2);
        REQUIRE(functionCall->getPayloadSize() == 28);
        auto [name, undecodedData] = functionCall->getFunctionName();
        REQUIRE(name == "print");
        std::string text;
        functionCall->decodeParameter(text, undecodedData);
        REQUIRE(text == "Hello World of 2022");
        REQUIRE(undecodedData.size() == 0);
    }
    GIVEN("Raw data of a call to 'print' function with a small string, a string and a number as parameters") {
        std::vector<uint8_t> raw{
          0x03, 0x04, 0x00, 0x00, 0xb1, 0x01, 0x00, 0x00, 0x04, 0x07, 0x63, 0x70, 0x70, 0x54, 0x65, 0x73, 0x74, 0x04, 0x35,
          0x54, 0x65, 0x78, 0x74, 0x65, 0x20, 0x64, 0x65, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20, 0x73, 0x75, 0x66, 0x66, 0x69,
          0x73, 0x61, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x6c, 0x6f, 0x6e, 0x67, 0x20, 0x70, 0x6f, 0x75, 0x72, 0x20, 0x63, 0x68,
          0x61, 0x6e, 0x67, 0x65, 0x72, 0x20, 0x64, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x05, 0x65, 0x01, 0x62,
          0x69, 0x67, 0x54, 0x65, 0x78, 0x74, 0x20, 0x3a, 0x20, 0x54, 0x65, 0x78, 0x74, 0x65, 0x20, 0x64, 0x65, 0x20, 0x74,
          0x65, 0x73, 0x74, 0x20, 0x73, 0x75, 0x66, 0x66, 0x69, 0x73, 0x61, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x6c, 0x6f, 0x6e,
          0x67, 0x20, 0x70, 0x6f, 0x75, 0x72, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x72, 0x20, 0x64, 0x65, 0x20, 0x66,
          0x6f, 0x72, 0x6d, 0x61, 0x74, 0x54, 0x65, 0x78, 0x74, 0x65, 0x20, 0x64, 0x65, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20,
          0x73, 0x75, 0x66, 0x66, 0x69, 0x73, 0x61, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x6c, 0x6f, 0x6e, 0x67, 0x20, 0x70, 0x6f,
          0x75, 0x72, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x72, 0x20, 0x64, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61,
          0x74, 0x20, 0x2d, 0x20, 0x62, 0x69, 0x67, 0x54, 0x65, 0x78, 0x74, 0x20, 0x3a, 0x20, 0x54, 0x65, 0x78, 0x74, 0x65,
          0x20, 0x64, 0x65, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20, 0x73, 0x75, 0x66, 0x66, 0x69, 0x73, 0x61, 0x6d, 0x65, 0x6e,
          0x74, 0x20, 0x6c, 0x6f, 0x6e, 0x67, 0x20, 0x70, 0x6f, 0x75, 0x72, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x72,
          0x20, 0x64, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x54, 0x65, 0x78, 0x74, 0x65, 0x20, 0x64, 0x65, 0x20,
          0x74, 0x65, 0x73, 0x74, 0x20, 0x73, 0x75, 0x66, 0x66, 0x69, 0x73, 0x61, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x6c, 0x6f,
          0x6e, 0x67, 0x20, 0x70, 0x6f, 0x75, 0x72, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x72, 0x20, 0x64, 0x65, 0x20,
          0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x20, 0x2d, 0x20, 0x62, 0x69, 0x67, 0x54, 0x65, 0x78, 0x74, 0x20, 0x3a, 0x20,
          0x54, 0x65, 0x78, 0x74, 0x65, 0x20, 0x64, 0x65, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20, 0x73, 0x75, 0x66, 0x66, 0x69,
          0x73, 0x61, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x6c, 0x6f, 0x6e, 0x67, 0x20, 0x70, 0x6f, 0x75, 0x72, 0x20, 0x63, 0x68,
          0x61, 0x6e, 0x67, 0x65, 0x72, 0x20, 0x64, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x54, 0x65, 0x78, 0x74,
          0x65, 0x20, 0x64, 0x65, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20, 0x73, 0x75, 0x66, 0x66, 0x69, 0x73, 0x61, 0x6d, 0x65,
          0x6e, 0x74, 0x20, 0x6c, 0x6f, 0x6e, 0x67, 0x20, 0x70, 0x6f, 0x75, 0x72, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65,
          0x72, 0x20, 0x64, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x20, 0x2d, 0x20, 0x03, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x50, 0x76, 0x40};

        auto functionCall =
          msg::FunctionCall::castFromRawData(std::span(reinterpret_cast<const std::byte*>(raw.data()), raw.size()));
        REQUIRE(functionCall->getParametersCount() == 4);
        REQUIRE(functionCall->getPayloadSize() == 433);
        auto [name, undecodedData] = functionCall->getFunctionName();
        REQUIRE(name == "cppTest");
        std::string text;
        functionCall->decodeParameter(text, undecodedData);
        REQUIRE(text == "Texte de test suffisament long pour changer de format");
        
        functionCall->decodeParameter(text, undecodedData);
        REQUIRE(text.starts_with("bigText : Texte de test suffisament long pour changer de format"));
        REQUIRE(text.size() == 357);
        REQUIRE(text.ends_with("suffisament long pour changer de format - "));

        int value;
        functionCall->decodeParameter(value, undecodedData);
        REQUIRE(value == text.size());
        REQUIRE(undecodedData.size() == 0);

        
          
    }
}