#include <http/WebSocket.hpp>
#include <networking/NetworkingMock.hpp>
#include <tooling/HexDump.hpp>
#include <weblink/Messages.hpp>

#include <catch2/catch.hpp>

#include <span>
#include <stdexcept>

using namespace std;
using namespace webfront;
SCENARIO("Handshake message") {
    std::array<uint8_t, 2> raw{0x00, 0x00};
    auto handshake = msg::Handshake::castFromRawData(std::span(reinterpret_cast<const std::byte*>(raw.data()), raw.size()));

    REQUIRE(sizeof(*handshake) == 2);
    REQUIRE(handshake->getEndian() == msg::JSEndian::little);
}

SCENARIO("Ack message") {
    msg::Ack ack;

    REQUIRE(sizeof(ack) == 2);
}

SCENARIO("FunctionCall") {
    GIVEN("Raw data of a call to 'print' function with a small string as parameter") {
        std::array<uint8_t, 36> raw{0x03, 0x02, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x04, 0x05, 0x70, 0x72,
                                    0x69, 0x6e, 0x74, 0x04, 0x13, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57,
                                    0x6f, 0x72, 0x6c, 0x64, 0x20, 0x6f, 0x66, 0x20, 0x32, 0x30, 0x32, 0x32};

        auto functionCall =
          msg::FunctionCall::castFromRawData(std::span(reinterpret_cast<const std::byte*>(raw.data()), raw.size()));
        REQUIRE(functionCall->getParametersCount() == 2);
        REQUIRE(functionCall->getPayloadSize() == 28);
        auto [name, undecodedData] = functionCall->getFunctionName();
        REQUIRE(name == "print");
        std::string text;
        functionCall->decodeParameter(text, undecodedData);
        REQUIRE(text == "Hello World of 2022");
        REQUIRE(undecodedData.size() == 0);
    }
    GIVEN("Raw data of a call to 'cppTest' function with a small string, a string and a number as parameters") {
        std::vector<uint8_t> raw{
          0x03, 0x04, 0x00, 0x00, 0xb1, 0x01, 0x00, 0x00, 0x04, 0x07, 0x63, 0x70, 0x70, 0x54, 0x65, 0x73, 0x74, 0x04, 0x35,
          0x54, 0x65, 0x78, 0x74, 0x65, 0x20, 0x64, 0x65, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20, 0x73, 0x75, 0x66, 0x66, 0x69,
          0x73, 0x61, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x6c, 0x6f, 0x6e, 0x67, 0x20, 0x70, 0x6f, 0x75, 0x72, 0x20, 0x63, 0x68,
          0x61, 0x6e, 0x67, 0x65, 0x72, 0x20, 0x64, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x05, 0x65, 0x01, 0x62,
          0x69, 0x67, 0x54, 0x65, 0x78, 0x74, 0x20, 0x3a, 0x20, 0x54, 0x65, 0x78, 0x74, 0x65, 0x20, 0x64, 0x65, 0x20, 0x74,
          0x65, 0x73, 0x74, 0x20, 0x73, 0x75, 0x66, 0x66, 0x69, 0x73, 0x61, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x6c, 0x6f, 0x6e,
          0x67, 0x20, 0x70, 0x6f, 0x75, 0x72, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x72, 0x20, 0x64, 0x65, 0x20, 0x66,
          0x6f, 0x72, 0x6d, 0x61, 0x74, 0x54, 0x65, 0x78, 0x74, 0x65, 0x20, 0x64, 0x65, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20,
          0x73, 0x75, 0x66, 0x66, 0x69, 0x73, 0x61, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x6c, 0x6f, 0x6e, 0x67, 0x20, 0x70, 0x6f,
          0x75, 0x72, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x72, 0x20, 0x64, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61,
          0x74, 0x20, 0x2d, 0x20, 0x62, 0x69, 0x67, 0x54, 0x65, 0x78, 0x74, 0x20, 0x3a, 0x20, 0x54, 0x65, 0x78, 0x74, 0x65,
          0x20, 0x64, 0x65, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20, 0x73, 0x75, 0x66, 0x66, 0x69, 0x73, 0x61, 0x6d, 0x65, 0x6e,
          0x74, 0x20, 0x6c, 0x6f, 0x6e, 0x67, 0x20, 0x70, 0x6f, 0x75, 0x72, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x72,
          0x20, 0x64, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x54, 0x65, 0x78, 0x74, 0x65, 0x20, 0x64, 0x65, 0x20,
          0x74, 0x65, 0x73, 0x74, 0x20, 0x73, 0x75, 0x66, 0x66, 0x69, 0x73, 0x61, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x6c, 0x6f,
          0x6e, 0x67, 0x20, 0x70, 0x6f, 0x75, 0x72, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x72, 0x20, 0x64, 0x65, 0x20,
          0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x20, 0x2d, 0x20, 0x62, 0x69, 0x67, 0x54, 0x65, 0x78, 0x74, 0x20, 0x3a, 0x20,
          0x54, 0x65, 0x78, 0x74, 0x65, 0x20, 0x64, 0x65, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20, 0x73, 0x75, 0x66, 0x66, 0x69,
          0x73, 0x61, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x6c, 0x6f, 0x6e, 0x67, 0x20, 0x70, 0x6f, 0x75, 0x72, 0x20, 0x63, 0x68,
          0x61, 0x6e, 0x67, 0x65, 0x72, 0x20, 0x64, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x54, 0x65, 0x78, 0x74,
          0x65, 0x20, 0x64, 0x65, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20, 0x73, 0x75, 0x66, 0x66, 0x69, 0x73, 0x61, 0x6d, 0x65,
          0x6e, 0x74, 0x20, 0x6c, 0x6f, 0x6e, 0x67, 0x20, 0x70, 0x6f, 0x75, 0x72, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65,
          0x72, 0x20, 0x64, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x20, 0x2d, 0x20, 0x03, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x50, 0x76, 0x40};

        auto functionCall =
          msg::FunctionCall::castFromRawData(std::span(reinterpret_cast<const std::byte*>(raw.data()), raw.size()));
        REQUIRE(functionCall->getParametersCount() == 4);
        REQUIRE(functionCall->getPayloadSize() == 433);
        auto [name, undecodedData] = functionCall->getFunctionName();
        REQUIRE(name == "cppTest");
        std::string text;
        functionCall->decodeParameter(text, undecodedData);
        REQUIRE(text == "Texte de test suffisament long pour changer de format");

        functionCall->decodeParameter(text, undecodedData);
        REQUIRE(text.starts_with("bigText : Texte de test suffisament long pour changer de format"));
        REQUIRE(text.size() == 357);
        REQUIRE(text.ends_with("suffisament long pour changer de format - "));

        size_t value;
        functionCall->decodeParameter(value, undecodedData);
        REQUIRE(value == text.size());
        REQUIRE(undecodedData.empty());
    }
}

SCENARIO("FunctionReturn") {
    using Net = networking::NetworkingMock;

    GIVEN("A FunctionReturn message") {
        msg::FunctionReturn message;
        websocket::Frame<Net> frame{
          std::span(reinterpret_cast<const std::byte*>(message.header().data()), message.header().size())};
        networking::SocketMock socket;
        websocket::WebSocket<Net> ws(socket);

        WHEN("An exception is encoded") {
            std::string exceptionText = "Parameter error";
            auto exception = std::runtime_error(exceptionText);
            message.encodeParameter(exception, frame);
            ws.write(std::move(frame));

            THEN("Encoded frame should be") {
                auto encodedFrame = span(socket.debugBuffer.data(), socket.bufferIndex);
                REQUIRE(encodedFrame.size() == 2 + message.header().size() + 3 + exceptionText.size());
            }

            THEN("A Frame decoded should retrieve the encoded parameters") {
                websocket::FrameDecoder decoder;
                REQUIRE(decoder.parse(span(socket.debugBuffer.data(), socket.bufferIndex)));

                auto funcRet = msg::FunctionReturn::castFromRawData(decoder.payload());
                REQUIRE(funcRet->getParametersCount() == 1);
                REQUIRE(funcRet->getPayloadSize() == 3 + exceptionText.size());

                std::string text;
                auto undecodedData = funcRet->payload();
                funcRet->decodeParameter(text, undecodedData);
                REQUIRE(text == exceptionText);
                REQUIRE(undecodedData.empty());
            }
        }

        WHEN("A tuple is encoded") {
            std::tuple<int, std::string> value{42, "Hello World"};
            message.encodeParameter(value, frame);
            ws.write(std::move(frame));
            cout << "Socket wrote :\n" << utils::hexDump(span(socket.debugBuffer.data(), socket.bufferIndex)) << '\n';

            THEN("An erroneous tuple should trigger an exception") {
                websocket::FrameDecoder decoder;
                REQUIRE(decoder.parse(span(socket.debugBuffer.data(), socket.bufferIndex)));
                auto funcRet = msg::FunctionReturn::castFromRawData(decoder.payload());
                std::tuple<int, std::string, int> tupleValue;
                auto undecodedData = funcRet->payload();
                REQUIRE_THROWS_AS(funcRet->decodeParameter(tupleValue, undecodedData), std::runtime_error);
            }
            THEN("A Frame decoded should retrieve the encoded parameters") {
                websocket::FrameDecoder decoder;
                REQUIRE(decoder.parse(span(socket.debugBuffer.data(), socket.bufferIndex)));
                auto funcRet = msg::FunctionReturn::castFromRawData(decoder.payload());
                REQUIRE(funcRet->getParametersCount() == 3);
                REQUIRE(funcRet->getPayloadSize() == 24);

                std::tuple<int, std::string> tupleValue;
                auto undecodedData = funcRet->payload();
                funcRet->decodeParameter(tupleValue, undecodedData);
                REQUIRE(std::get<0>(tupleValue) == 42);
                REQUIRE(std::get<1>(tupleValue) == "Hello World");
                std::cout << undecodedData.size() << "\n";
                REQUIRE(undecodedData.empty());
            }
        }
    }
}